// Servicio de Previsión de Tesorería
// Este servicio contiene la lógica de negocio para calcular previsiones

export interface ForecastPeriod {
  period_date: string;
  initial_balance: number;
  planned_income: number;
  planned_expenses: number;
  final_balance: number;
  notes?: string;
  alert_level?: 'safe' | 'warning' | 'danger';
}

export interface TreasuryForecast {
  id?: string;
  user_id?: string;
  period_type: 'monthly' | 'weekly';
  start_date: string;
  forecast_data: ForecastPeriod[];
  created_at?: string;
  updated_at?: string;
}

export const treasuryForecastService = {
  /**
   * Calcula el nivel de alerta según el saldo
   */
  calculateAlertLevel(balance: number): 'safe' | 'warning' | 'danger' {
    if (balance < 0) return 'danger';
    if (balance < 2000) return 'warning';
    return 'safe';
  },

  /**
   * Genera periodos vacíos para inicializar la previsión
   */
  generateEmptyPeriods(
    startDate: string,
    periodType: 'monthly' | 'weekly',
    count: number,
    initialBalance: number
  ): ForecastPeriod[] {
    const periods: ForecastPeriod[] = [];
    const date = new Date(startDate);
    let currentBalance = initialBalance;

    for (let i = 0; i < count; i++) {
      const periodDate = new Date(date);
      
      periods.push({
        period_date: periodDate.toISOString().split('T')[0],
        initial_balance: currentBalance,
        planned_income: 0,
        planned_expenses: 0,
        final_balance: currentBalance,
        alert_level: this.calculateAlertLevel(currentBalance),
        notes: ''
      });

      // Avanzar periodo
      if (periodType === 'monthly') {
        date.setMonth(date.getMonth() + 1);
      } else {
        date.setDate(date.getDate() + 7);
      }
    }

    return periods;
  },

  /**
   * Recalcula todos los saldos en cascada
   */
  recalculateBalances(periods: ForecastPeriod[]): ForecastPeriod[] {
    return periods.map((period, index) => {
      const finalBalance = period.initial_balance + period.planned_income - period.planned_expenses;
      
      const updated = {
        ...period,
        final_balance: finalBalance,
        alert_level: this.calculateAlertLevel(finalBalance)
      };

      // Actualizar saldo inicial del siguiente periodo
      if (index < periods.length - 1) {
        periods[index + 1].initial_balance = finalBalance;
      }

      return updated;
    });
  }
};